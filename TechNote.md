# 기술기록

[![GPL2](https://img.shields.io/badge/license-GPL2-yellowgreen.svg)](https://github.com/parkkw09/parkSync/edit/master/LICENSE)

```
#docker 2
컨테이너를 만들어서 블라블라 SSH 셋업 하고 컨테이너를 이미지로 만들어서 허브.도커에 올리고
다른 컴터로 가서 그걸 내려받아 컨테이너로 만들고 작동시켜서 ssh 접속 까지 확인하였다.
와우 드디어 개인 이미지 생성 ! 문제는 이게 기억이 남으려나 엄청 복잡한데 ㅎㅎㅎㅎ
git 쓸줄 알고 cli에 익숙하면 금방할 것 같으나 본업이 아니므로 계속 기억하고 있을 수가 있을지 의문 ㅠ
2019.03.05
```

```
#코틀린노트 22
Viewpager2 라는게 나왔길래 써보려 했으나 배보다 배꼽이 더 큰 일이 터져서 캔슬.
viewpager 자체가 원래 배보다 배꼽이 더 크긴해.
recyclerview를 직접 쓸수있다는데...... 언젠간 써보자.
2019. 2. 25. 오후 6:22
```

```
#docker 1
음... 아쉬운대로 윈도우에 설치를 했더니 버추얼박스를 컨테이너로 사용한다고 한다....
음.... 버추얼박스랑 다른게 뭐죠?
컨테이너를 처음 가져왔을 때 느낌은 #배틀그라운드 처음 시작했을 때 느낌이구나.
2019.02.19
```

```
#코틀린노트 21
가속 가슴 한켠에 자리잡아 있던 androidx 수술 작업을 완료하였다.
친구가 찾아준 어떤 글에서는 머지 나이트메어라는 ㄷㄷㄷㄷㄷ.
암튼 잘되니 이제 androidx로 다 처리하자.
2019. 2. 15. 오후 4:55
```

```
#코틀린노트 20
그동안은 아무생각없이 뷰모델을 N개 만들었는데 가만히 보니
A라는 동작 하나를 위해 필요한 코드가 너무 많다는 생각이 들었다.
그래서 비슷한 애들을 통합으로 만들었으나 이거 누가 쓰고 있는지 알길이 없넼ㅋㅋㅋ
AAC의 매력인 cleared()가 아무짝에 쓸모가 없어짐.
그래서 원복해야겠다. ㅎㅎㅎㅎㅎ
2019. 2. 11. 오후 5:02

뷰모델이 원래 저렇게 쓰는게 맞더라 - 2019.04.01
```

```
#코틀린노트 19
신규 프로젝트에 Dagger를 사용하고 있는데 기존에는 AndroidInjector를 사용했다.
귀차니즘의 끝에서 탄생한 어마어마한 도구임이 분명하나 이걸 안쓰는 Dagger를 쓰려니 한창 고생했다.
결국 해내긴 했는데 AndroidInjector를 쓰기로 한건 함정. ㅎㅎㅎㅎ. 뭐 이러면서 배워나가는거지.

Scope는 Dependency에 예민하다.
2019. 1. 29. 오후 2:32
```

```
#코틀린노트 18
라이브 데이터를 쓸 경우 백그라운드 스레드에서 데이터를 처리해야할 경우가 생기는데
이때는 value가 아닌 postvalue로 처리한다. 크~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018. 11. 27. 오후 3:35
```

```
#코틀린노트 17
데이터바인딩도 이제 어느정도 손에 익었고 이제는 constraint layout이닷!
일단 엄청 헷깔리긴 한데 제대로 쓰면 좋긴 하지만 GUI 담당자와 개발자간의 가이드라인도 바뀌어야 할 듯....

정말 배울게 많아.
이거 회사 제대 다니려면 학원을 다녀야할 판이로구나.....
2018. 11. 22. 오후 5:33
```

```
#코틀린노트 16
데이터 바인딩의 단점
Dagger처럼 정해진 규격에 의해 자동으로 생성되는 코드가 있는데
만약에 다른 곳에서 문제가 생겨서 전체빌드가 안되면 자동 생성 코드를 못만들게 되고
데이터바인딩 코드에서 자동생성코드가 없다고 에러를 뿜는다.
문제는 CLI 빌드는 대부분 빌드에러가 확인이 되는데
안드로이드 스튜디오에서는 빌드 로그가 넘어가버리는 경우가 있어서
그냥 자동생성코드가 존재하지 않는다는 에러만 잔뜩 보여서
결과적으로 어디가 문제였는지 파악하기 애매해진다.
기본적으로 XML에 기존보다? 많은 내용을 구현하게 되는데
이 과정에서 문제가 생기면 일단 인텔리젠트 파서가 동작하긴 하지만 C, JAVA 만큼 보여주질 못하고
빌드 에러가 났을 경우 풀스택을 다 뿌리는 경향이 있어서 정작 어디가 에러났는지 찾기가 어렵다.
제대로 만들어 놓으면 이야~~~~~ 이 소리가 나오는데
만드는 과정에서 문제가 생기면 그거 찾기가 어렵다.
2018. 10. 18. 오전 10:25
```

```
#rx노트 5
데이터베이스 쓰기가 겁나 편해졌어용~
아...생각해보니 thread처리 안했네 ㅋㅋㅋㅋ
2018. 10. 17. 오후 5:40
```

```
#코틀린노트 15
구성하려는 화면에 아이템이 딱히 없고 리스트만 덜렁있어서
처음에는 리스트 아이템에 대한 데이터바인딩만 해보았다.
음.. 나름 괜찮았는데 오늘은 리스트 아이템을 저장하는 구간을 데이버바인딩으로 바꾸었다.
신세계다.....
엄청 직관적이라고 해야하나?
처음엔 이해가 어려운게 함정.
2018. 10. 17. 오후 5:39
```

```
#코틀린노트 14
그냥 데이터바인딩을 쓰면 좀 낫네? 정도인데 리스트에서 사용하니 확실히 어마어마하다..
뷰홀더는 아주 심플해지고 나중에 유지보수도 편하게 처리가 가능하다.
특정 메소드를 직접 연결할 수도 있으며 임의로 import하여 처리도 가능하다.
적당히 하려했는데 하다보니 어지간한건 다 해보게 됨.
엄청 복잡하게도 사용이 가능해 보인다.
근데 그러진 말자. 이미 머릿속에 들어오는게 너무 많다. ㅋㅋㅋ
2018. 10. 16. 오후 5:39
```

```
#코틀린노트 13
데이터바인딩.......가장 별거 아니지만 가장 설명하기 난해하다.
안드로이드 초창기에 XML마져도 만지기 싫다고
모든 코드를 자바로 만드신 분을 봤는데 그때가 잠시 떠오른다. ㅎ
프로그래밍은 어떻게 만들던 최적화가 최우선이기 하나
요즘은 분명 트렌드를 따라가는 경향이 있다.
그래서 시작한 것이긴 하지만 이건 정말 설명하기가 난해하다.
간단하게 접근하면 MVVM에서 뷰와 뷰모델간의 구현코드 조차
완전 깔끔하게 분리하겠다는 의지가 강하다고 볼수있고
WPF나 MVVM을 통해서 접근한 거라면 이렇게 이해하는 것이 빠를 것 같다.
일반적으로 자바 기반 안드로이드를 하고 있었다면 뷰의 속성값들의 집합인 XML코드가
그 기능이 확장되어 구현부에 직접 접근을 하거나
Observable한 코드 운용이 가능하다고 보면 될듯.
구현부(혹은 뷰모델) 코드가 확실히 줄어들 순 있으나
새로 배우는 입장에서는 간단하게 구현할 수 있는 화면을 만들 때 까지
너무 많은 것을 알아야 시도해볼 수 있는 상황이 올수도 있고
혹은 그 반대로 알아야될 내용을 죄다 건너 뛰고
앱을 개발하는 상황이 올수도 있어 보인다.
확실한건 최근 인싸? 세트를 보게되면 코드가 엄청 줄어들고 깔끔해진다.
2018. 10. 16. 오후 3:47
```

```
#rx노트 4
3콤보 정돈 처리해줘야 rx지.
1) 데이터A를 가져온다.
2) 데이터 A를 저장한다.
3) 데이터 A의 B를 가져온다.
4) 데이터 B를 저장한다.
4-1) 저장이 완료될 때 까지 기다린다.
5) 데이터 A를 꺼내면서 동시에 데이터 B를 꺼낸다.
6) 데이터 A와 B의 조합으로 데이터 C를 만든다.
7) 데이터 C를 저장한다.
7-1) 데이터 C가 저장이 완료가 될 때 까지 기다린다.
2018. 10. 1. 오후 11:09
```

```
#코틀린노트 12
MVC - 액티비티에서 모든 명령을 받아서 처리하고 화면 갱신을 시도 한다.

MVP - 액티비티는 뷰의 명령처리를 위해 Presenter라는 명령처리 구간을 만들어
액티비티의 상태나 뷰에서 전달되는 명령을 넘긴다.
Presenter는 이때 비지니스 로직이나 데이터 처리를 위한 모델을 자신이 갖고 있게 되는데
(MVC는 액티비티가 다 처리하므로 모델도 액티비티가 들고 있음)
뷰의 명령에 따라 모델을 적당히 가공하고 가동된 데이터를 이용하여 뷰를 갱신한다.
이때 뷰를 갱신하기 위해 Presenter는 뷰의 핸들을 액티비티로 부터 가져오게 된다.

MVVM - MVP와 기본 동작은 완전이 동일하지만 Presenter 역할을 하는 ViewModel은 뷰의 핸들을 직접 들고 있지 않는다.
(실제 내부에도 없는지는 모른다) 다만 안드로이드에서는 데이터 바인딩이란 기술을 이용하여
뷰와 뷰모델을 직접 연결하고 뷰를 통해 전달되는 명령이나
혹은 모델을 이용한 데이터 가공이후의 화면 갱신을 위해 옵저버 패턴을 활용한다.
이를 위한 전용 클래스가 존재한다.
데이터 바인딩을 사용하지 않더라도 라이브 데이터라는 기술을 이용하여 비슷하게 구현이 가능하다.

DI - MVP나 MVVM을 제대로 처리하기 위해서는 각 역할 별로 클래스를 나눠놓고 특정시점에 생성을 해야 한다.
문제는 이 생성자 구현부가 매우 지저분해질 수도 있고
변경점이 존재할 때는 생성한 모든 구간을 다 수정해야 해서 생산성이 좋지 못하다.
그래서 DI라는 기술을 이용해서 인스턴스 생성 구간을 잘 설계하면 모듈이라 불리는 DI 처리 클래스를
조작하여 관리가 편해질 수 있다.

MVP나 MVVM을 사용하는 이유 - 성능을 기대해서 만들어진 개념은 아닌 것 같다.
일단 MVC로 하면 기능이 세분화 되긴 하지만 M V C 에 해당하는 내용들이 강결합이 될 수 밖에 없어서
코드 알아보기가 어렵고 테스트는 더더욱 어려워진다.
MVP나 MVVM는 역할별로 완전 독립을 추구하는 스타일이기 때문에
(물론 완전 분리는 현실적으로 어렵다.)
특정 구간을 기준으로 테스트 모듈 작성이 쉬워진다.
제일 중요한건 코드 보기가 아주 간결해지고
(물론 해당 패턴을 알아 볼 수 있을 경우)
최근 트랜드인 보일레이트 코드를 최소화 할 수 있다.
패턴을 지켜서 코딩해야 하기 때문에 귀차니즘에 의한 코딩 유혹을
떨쳐내야 제대로 된 코드를 만들 수 있다.
(나중에 유지보수가 편하다는 것이지 만들기는 엄청 귀찮다. 처음 MVC를 시작했을 때 처럼....)
MVC에 비해 단순 반복 코드가 많아진다.
2018. 9. 7. 오후 4:44
```

```
#코틀린노트 11
내가 UI에 이렇게 까지 공을 들인 적이 있는가?
2018. 8. 22. 오후 5:39
```

```
#코틀린노트 10
아무리 생각을 해도 MVVM을 하다보니 더 지저분해보여. ㅋㅋㅋㅋ
일단 입질 왔을 때 다 만들어보자.
2018. 8. 21. 오후 4:06
```

```
#코틀린노트 9
싱글톤 레포지터리 혼종
2018. 8. 17. 오후 2:00
```

```
#코틀린노트 8
드디어 라이브 데이터의 정체를 파악했다.
2018. 8. 10. 오후 2:33
```

```
#코틀린노트 7
결국 내가 했던거네 ㅋㅋㅋㅋㅋ
코드 지저분한거 싫어서..
난 또 뭐 대단한게 있는 줄 알았다 ㅋ
2018. 8. 10. 오후 1:19
```

```
#코틀린노트 6
손대다 보니 다 뜯어 고치게 만드는 dagger2 캬~~~
2018. 8. 8. 오후 12:43
```

```
#코틀린노트 5
처음 retrofit을 알게 되었을 때도 어차피 내가 필요한 것만 쓴다는 것을 목표로 접근했었는데 지금와서 보니 결국 다 써야함. 결국 MVVM든 MVP든 거기로 가야함. 결국 대거에 손을 댐 ㅠ
배보다 배꼽이 더 큰..... 
모바일.. 더 나아가 임베디드 개발의 가장 중요한 키워드는
절약과 단축이거늘.. 이젠 복잡도가 어지간한 윈도우 프로그램 급인 거 같다.
2018. 8. 7. 오후 12:36
```

```
#rx노트 3
하란대로 안하고 내 맘대로 만들었더니 메모리가 줄줄세네ㅠㅠ
2018. 8. 7. 오후 12:37
```

```
#코틀린노트 4
가끔씩 컴파일에러가 났을 경우
어디서 문제인지를 안알랴줌
2018. 7. 3. 오후 3:52
```

```
#코틀린노트 3
드디어 rxandroid와 room을 결합한 원형이 나왔다.
그동안 문제점이 무엇인지 찾았는데 대체할 방법을 모르겠다.
어디다 물어봐야함?
2018. 6. 22. 오후 3:20
```

```java
#rx노트 2
reduce, bifunction
var sales = ArrayList<Pair<String, String>>()
sales.add("TV" to "2500")
sales.add("Camera" to "300")
sales.add("TV" to "1600")
sales.add("Phone" to "800")
sales.add("TV" to "400")

val tvSales: Maybe<String> = Observable.fromIterable(sales)
.filter{sale -> "TV" == sale.first}
.map{sale -> sale.second}
.reduce{
sale1, sale2 -> "[[$sale1] + [$sale2] = [${sale1 + sale2}]]"
}
tot = [[[[2500] + [1600] = [25001600]]] + [400] = [[[2500] + [1600] = [25001600]]400]]

A = [[2500] + [1600] = [25001600]]
tot = [[A] + [400] = [A]400]]

이해하기 무척이나 어렵군요 ㅎㅎㅎㅎㅎㅎㅎㅎㅎ
2018. 6. 22. 오후 1:12
```

```
#rx노트 1
장난나랑지금하냐
2018. 6. 21. 오후 6:15
```

```
#코틀린노트 2
액티비티를 호출할때 to 형태의 pair 값을 넘기면 get intent extra 형태로
수신측 액티비티에서 값을 확인할 수 있다.
이게 원래 되었던건지는 잘 모르겠으나 intent setextra같은 코드가 오나전 간결해진다.
2018. 6. 21. 오전 11:54
```

```
#코틀린노트 1
object로 만들면 전지전능 클래스인 싱글톤으로 구성이 된다.
책이나 자료에는 sychronize형태로 만들어진다고 했으나 디컴파일 해보면 그렇지 못하다.
thread safe형태로 가려면 아무래도 lazy를 써야 하는 듯 하다.
이것도 기본적인 구성일 때 이야기이고 인스턴스를 얻고자 할때
파라메터가 필요할 경우엔 이런것도 다 소용없고
그냥 자바에서 만들듯이 만들어야 한다.
다만 static class개념이 없으므로 object를 이용해서 만들어야 한다.
여기도 마찬가지로 sychronize처리를 해주어야 디컴파일 했을 때
내가 아는 그게 만들어진다.
어디 물어볼 것이 없는게 함정.
2018. 6. 20. 오후 1:01
```
